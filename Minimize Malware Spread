class Solution {
    int findParent(int a,int par[])
    {
        if(par[a]==-1)
            return a;
       return par[a]=findParent(par[a],par);
    }
    int union(int a,int b,int parent[],int rank[],int malware[])
    {
        int c = findParent(a,parent),d = findParent(b,parent);
        if(c!=d)
        {
            if(malware[c]>=1)
            {
                parent[d]=c;
                rank[c]+=rank[d];
                malware[c]+=malware[d];
            }
            else
            {
                parent[c]=d;
                rank[d]+=rank[c];
                malware[d]+=malware[c];
               
                
            }
          
            
        }
        return c;
    }
    public int minMalwareSpread(int[][] graph, int[] initial) {
     int minm = initial[0],n = graph.length,ans=-1;

     int parent[]=new int[n],malware[]=new int[n],rank[]=new int[n];
     Arrays.fill(parent,-1);
     Arrays.fill(rank,1);
     
     for(int el:initial)
     {

        malware[el]=1;
        minm = Math.min(minm,el);
     }
     int maxm=0;
     for(int i=0;i<n;i++)
     {
         for(int j=0;j<n;j++)
         {
             if(graph[i][j]==1)
             {
                
               union(i,j,parent,rank,malware);
              
             }
         }
     }
     int node = Integer.MAX_VALUE;
     
     for(int i=0;i<n;i++)
     {
         int par = findParent(i,parent);
         //System.out.println(par+" "+parent[par]+" "+rank[par]+" "+malware[par]);
         if(malware[par]==1)
         {
             if(maxm<rank[par])
             {
                 maxm = rank[par];
                 node = par;
             }
             else if(maxm == rank[par])
                node = Math.min(node,par);
         }
     }
    return node==Integer.MAX_VALUE?minm:node;   
    }
}
